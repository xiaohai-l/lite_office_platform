# 轻量级工作平台
## Day1
1. 利用spring boot初始化工具初始化所需框架和依赖
2. 利用navicat初始化MySql连接，并生成初始数据库
3. 修改application.yml文件，连接数据库
4. 编写Result文件，统一后端向前端的抛出文件
5. 编写实体User，实际含义是利用java操作在连接的数据库中建立User表
6. 编写UserRepository文件，该文件利用Spring框架的Bean库，仅仅需要声明接口，自动实现类。但是方法名必须按照固定格式，比如Find..By。Repository本质小型仓库，以后很多的类实现都要调用它
7. 编写UserService文件,该文件作为Service的接口,统一Service的规范
8. 编写UserServiceimp1文件,具体实现UserService接口的功能
9. 关于Repository和Service的理解：Repository是Bean的类型，也就是说Bean是个工具库Spring实例，Repository-Bean的作用就是从Spring这个工具库中拿出一些前人写过的工具，而service就是相当于工匠的个性化需求，通过Service来声明这些需求，然后用具体的类实现，具体类实现中会用到Repository
10. Bean就是Spring框架创建和管理的对象实例，是Spring应用程序的"细胞单位"。普通对象 = 你自己生的孩子，你自己养 Spring Bean = Spring生的孩子，Spring帮你养，还帮你处理各种关系

## Day2
1. 编写SecurityConfig文件。负责密码加密/解密，安全过滤器实现安全功能，其中登入失败登入成功登出成功处理器实现
2. 加密/解密采用BCrypt算法，给他一个明文，他会随机生成盐值加哈希值作为密文保存在数据库中，实现前后端分离，验证时从数据库解出盐值再进行哈希处理，看哈希值是否一致
3. SecurityFilterChain：安全过滤器链（多个过滤器） HttpSecurity：HTTP安全配置器（用来配置规则） filterChain：配置过滤器链的方法
4. 安全过滤链的本质是对权限进行管理，并对不同的情况调用相应的处理器
5. JSON是前端能看懂的语言，在登陆页面，我们第一次接触到前端与后端的交互 前端看不懂JAVA，所以用Jackon将java对象变成JSON 具体通过jackon的核心类ObjectMapper及其相应方法writeValueAsString完成的

## Day3
1. 创建包DTO，统一管理数据传输对象
2. 编写RegisterRequest，即对用户注册请求类，其中用@notblank，@size，@email对数据进行合法性判断
3. 编写loginrequest，即登录请求类，登陆时传递登录参数
4. 编写AuthController,即认证控制器，规定了URL的格式；同时对于不同的请求，即注册和登录，根据URL的不同，调用不同的参数
5. 注册请求，先检查，再创建，最后保存
6. 使用Apifox测试post方法接口，均通过
7. 接着实现对当前用户的参数查询接口，这个接口的最终目标是要传给前端显示的，所以不要传密码。所以，需要一个新的数据传送对象（DTO）UserProfileDTO。
8. 目前只实现了DTO的设计，我们的目的是为了实现对当前用户的查询和修改，接着在Userservice中声明接口，并在UserServiceImpl实现方法
9. 为了方便以后开发，我们先编写SecurityUtil工具，这个工具用来返回当前用户实体和id，注意此处DTO包含密码
10. 编写UserController，我们想要实现对用户的修改，UserController实现了对当前用户的查询和修改
11. UserController的查询对当前登录用户的检查，若未登录则抛出异常R，若登录返回UserProfileDTO
12. UserController的修改先得有一个修改目标和修改内容，修改目标由id唯一决定。
13. 第一步，获取当前用户信息；第二部，判断登录状态；第三步，确保id一致

## Day4
今日有事，休息。

## Day5
1. DTO处理流程：用户点击图形化页面--前端生成json文件--controller识别json并转换成定义的DTO--调用service层进行处理--最后反映在数据库
2. 有些复杂的跨表查询JPA做不到，所以需要使用sql语言
3. 深刻理解JPA和SQL的不同，JPA做不到通过parentId直接操作对应的具体的部门对象——就像数据库那样————所以需要先用方法找到实体
4. 在service层中，先声明接口，再具体实现
5. DepartmentService包括创建部门，更新部门，删除部门，获取部门信息，获取完整部门树，获取完整部门树的关键是convertToTreeDTO，关键在于通过递归遍历把department实体转换成dto